# 8-bit-Tank-Game
Yandex Lyceum Project

Проверяйте раскладку. WASD только на Eng    !
Запуск возможен только с установленными библиотеками Sys и Pyqt5.

Породия на 8битные танчики от Всеволода.

Презентация проекта - presentation/8 bit Tank Game
Видео в презентации или presentation/assets/Без названия3

https://github.com/sevadp/8-bit-Tank-Game





Пояснительная записка:

Идея проектаЖ
Разработка игры детства. Породия на старенькие 8битные танки

Цель проектаЖ
Портировать старую игру на Python - PyQT5. Развлечение детей и развитие их логики

Оптимизация:
Используется множество функций, которые делают код более простым и быстрым

Конкретно о функциях:

Изначально в init и initui мы инициализируем объекты. Танки, списки блоков, игровой цикл.
Далее создаем карту в def create_map() из файла assets/map.txt. (640x640). ЕЁ МОЖНО МЕНЯТЬ! НО СТРУКТУРУ
СОХРАНЯТЬ ОБЯЗАТЕЛЬНО) 10х10. Доступно 3 блока. Кирпичи(можно ломать), листва(можно в ней скрываться), камень(нельзя сломать)


Переходим к игровому процессу:

Для управления танков 1 игрок испольует WASD + Space(стрельба), а второй Стрелочки + mouse.
Функции, которые отслеживают нажатия с клавиатуры:
KeyPressEvent - информация о нажатии клавиши
KeyReleaseEvent - информация об отжатии клавиши
Т.к в PyQT5 нельзя отслеживать, какие кнопки нажаты одновременно, использую 2 функции. Например, 1 игрок нажал W, а второй Key_Up.
Программа продолжает получать информацию только об Key_Up, хоть W еще не отжата. Для того, чтобы первый игрок продолжал двигаться, 
используется переменная self.put = 1 и self.move. Которые выставляют направление и установленность нажатия клавиши.
Когда игрок отжимает клавишу, ReleaseEvent выставляет put значение 0, после чего танк перестает двигаться.
Таким образом получается, что движение танков плавное и не имеет зависимость от другого игрока. Space и Mouse вызывают создание пули

В момент нажатия этих клавиш, у нас пополняется список self.bullets и self.life. Создается картинка, которая по игровому циклу движется.
Когда истекает её срок жизни(указывается в life), она удаляется. Направление так же находится в life. Оно устанвливается от self.move, это
сторона, в которую направлен танк. Таким образом, можно создавать бесконечное количество пуль, каждая из которых будет независимой.

Процесс движения пуль реализуется в move_bullet.

Для того, чтобы танк двигался вместе с пулями, используется игровой цикл. 
self.timer = QBasicTimer()
В начале игры стартует таймер, со скоростью обновления 12мс(84 fps). Он вызывает функцию timerEvent 84 раза за секунду.
Если у нас установлено движение танка, то танк автоматически двигается. Если есть живые пули, то они, имея своё направление и жизнь, так же
двигаются 84 раза за секунду. 

В move_bullet можно найти функцию def probitie. Данная функция проверяет, попала ли пуля в танк. Если пуля находится после
движения в координатах танка +- 48.(48х48 - танк), то таймер останавливается и игра заканчивается. Точного победителя можно
узнать в консоли игры.

Эта функция вызывается в timerEvent каждый раз. Так же там вызывается с движением танка и пули check_move(1-4) и check_brick.
check_move(1-4) Проверка. Если перед танком находится кирпич, то движение отклоняется и танк остается на месте. 4 стороны 
у квадрата 64x64, разные проверки и свои функции. check_brick используется для пули. Если пуля врезается в кирпич, то она удаляется.
Если же это был блок, который не ломается, то пуля просто пропадает.

Есть еще функция check_tank. Эта проверка делается на каждый танк при движении. Таким образом, танки не могут наехать друг на друга, 
они просто останавливаются.


Возможные пули развития:
1) Динамическая карта(не только 10x10 640x640)
2) Больше танков
3) Добавление звуков, респавн и т.д
4) Продолженние после смерти, обновление игры или респавн в другой точке
5) Игровое меню, с выбором карт.
6) Больше карт, не только базовая map.txt


